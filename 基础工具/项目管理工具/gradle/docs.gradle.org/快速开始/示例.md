# 示例

## Android

- [构建 Android 应用程序](https://docs.gradle.org/current/samples/sample_building_android_apps.html)：构建一个简单的 Android 应用程序。

## 建立组织

- [复合构建基础](https://docs.gradle.org/current/samples/sample_composite_builds_basics.html)：定义和使用复合构建
- [Composite Builds Declared Substitutions](https://docs.gradle.org/current/samples/sample_composite_builds_declared_substitutions.html)：在不发布的情况下应用和测试下游依赖项中的更改。
- [Composite Builds Hierarchical Multirepo](https://docs.gradle.org/current/samples/sample_composite_builds_hierarchical_multirepo.html)：定义和使用复合构建来组合多个独立的构建。
- [复合构建插件开发](https://docs.gradle.org/current/samples/sample_composite_builds_plugin_development.html)：在构建中开发 Gradle 插件而不发布。
- [Gradle 插件](https://docs.gradle.org/current/samples/sample_gradle_plugin.html)：将构建逻辑组织到用 Java 编写的 Gradle 插件中。
- [在子项目之间共享构建逻辑](https://docs.gradle.org/current/samples/sample_convention_plugins.html)：将构建逻辑组织成可重用的部分
- [在多仓库设置中共享构建逻辑](https://docs.gradle.org/current/samples/sample_publishing_convention_plugins.html)：组织和发布构建逻辑以在其他项目中重用
- [与构建逻辑构建共享约定插件](https://docs.gradle.org/current/samples/sample_sharing_convention_plugins_with_build_logic.html)：在主构建和构建逻辑构建中重用约定插件
- [构建软件项目](https://docs.gradle.org/current/samples/sample_structuring_software_projects.html)：使用 Gradle 构建软件产品项目

## [C++](https://docs.gradle.org/current/samples/index.html#c)

- [构建 C++ 应用程序](https://docs.gradle.org/current/samples/sample_building_cpp_applications.html)：逐步设置 C++ 应用程序项目。
- [构建 C++ 库](https://docs.gradle.org/current/samples/sample_building_cpp_libraries.html)：逐步设置 C++ 库项目。

## Groovy 

- [构建 Groovy 应用程序](https://docs.gradle.org/current/samples/sample_building_groovy_applications.html)：逐步设置 Groovy 应用程序项目。
- [使用库构建 Groovy 应用程序](https://docs.gradle.org/current/samples/sample_building_groovy_applications_multi_project.html)：逐步使用库设置 Groovy 应用程序项目。
- [构建 Groovy 库](https://docs.gradle.org/current/samples/sample_building_groovy_libraries.html)：逐步设置 Groovy 库项目。
- [发布 Groovy 库](https://docs.gradle.org/current/samples/sample_publishing_groovy_libraries.html)：将 Groovy 库发布到二进制存储库。

## Java

- [使用 JaCoCo 从应用程序/发行版聚合代码覆盖率（孵化） ：报告使用](https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_code_coverage_distribution.html)[JaCoCo](https://www.jacoco.org/jacoco/)的多模块项目的应用程序/发行版的代码覆盖率。
- [使用独立实用程序项目 (Incubating) 使用 JaCoCo 聚合代码覆盖率：使用 JaCoCo](https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_code_coverage_standalone.html)[报告](https://www.jacoco.org/jacoco/)多模块项目的代码覆盖率。
- [聚合应用程序/分发的测试结果（孵化）](https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_test_aggregation_distribution.html)：使用多模块项目的应用程序/分发报告所有测试结果。
- [使用独立实用程序项目聚合测试结果（孵化）](https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_test_aggregation_standalone.html)：使用独立实用程序项目作为多模块项目的一部分报告所有测试结果。
- [构建 Java 应用程序](https://docs.gradle.org/current/samples/sample_building_java_applications.html)：逐步设置 Java 应用程序项目。
- [使用库构建 Java 应用程序](https://docs.gradle.org/current/samples/sample_building_java_applications_multi_project.html)：逐步使用库设置 Java 应用程序项目。
- [构建 Java 库](https://docs.gradle.org/current/samples/sample_building_java_libraries.html)：逐步设置 Java 库项目。
- [发布 Java 库](https://docs.gradle.org/current/samples/sample_publishing_java_libraries.html)：将 Java 库发布到二进制存储库。
- [使用测试套件（孵化）在多存储库设置中共享构建逻辑](https://docs.gradle.org/current/samples/sample_incubating_publishing_convention_plugins.html)：组织和发布构建逻辑，以便使用新的测试套件 API 在其他项目中重用。
- [使用额外的测试类型](https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_additional_test_types.html)：向项目添加额外的测试类型（例如集成测试）。
- [使用带有测试套件的附加测试类型（孵化）](https://docs.gradle.org/current/samples/sample_incubating_jvm_multi_project_with_additional_test_types.html)：使用新的测试套件 API 将附加测试类型（例如集成测试）添加到项目中。
- [使用工具链](https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_toolchains.html)：使用工具链配置 JVM 以用于编译和测试。

## [Java 模块](https://docs.gradle.org/current/samples/index.html#java_modules)

- [构建 Java 模块](https://docs.gradle.org/current/samples/sample_java_modules_multi_project.html)：构建 Java 模块和模块化 Java 应用程序。
- [使用黑盒测试](https://docs.gradle.org/current/samples/sample_java_modules_multi_project_with_integration_tests.html)构建 Java 模块：使用黑盒集成测试构建 Java 模块。
- [使用测试套件构建带有黑盒测试的 Java 模块（孵化）](https://docs.gradle.org/current/samples/sample_incubating_java_modules_multi_project_with_integration_tests.html)：使用新的测试套件 API 构建带有黑盒集成测试的 Java 模块。
- [使用遗留库构建 Java 模块](https://docs.gradle.org/current/samples/sample_java_modules_with_transform.html)：构建一个集成遗留库的模块化 Java 应用程序。

## Kotlin

- [构建 Kotlin 应用程序](https://docs.gradle.org/current/samples/sample_building_kotlin_applications.html)：逐步设置 Kotlin 应用程序项目。
- [使用库构建 Kotlin 应用程序](https://docs.gradle.org/current/samples/sample_building_kotlin_applications_multi_project.html)：逐步使用库设置 Kotlin 应用程序项目。
- [构建 Kotlin 库](https://docs.gradle.org/current/samples/sample_building_kotlin_libraries.html)：逐步设置 Kotlin 库项目。

## Scala

- [构建 Scala 应用程序](https://docs.gradle.org/current/samples/sample_building_scala_applications.html)：逐步设置 Scala 应用程序项目。
- [使用库构建 Scala 应用程序](https://docs.gradle.org/current/samples/sample_building_scala_applications_multi_project.html)：逐步使用库设置 Scala 应用程序项目。
- [构建 Scala 库](https://docs.gradle.org/current/samples/sample_building_scala_libraries.html)：逐步设置 Scala 库项目。

## Spring

- [构建 Spring Boot Web 应用程序](https://docs.gradle.org/current/samples/sample_building_spring_boot_web_applications.html)：构建一个简单的 Spring Boot 应用程序。

## Swift

- [构建 Swift 应用程序](https://docs.gradle.org/current/samples/sample_building_swift_applications.html)：逐步设置 Swift 应用程序项目。
- [构建 Swift 库](https://docs.gradle.org/current/samples/sample_building_swift_libraries.html)：逐步设置 Swift 库项目。

## [使用凭证](https://docs.gradle.org/current/samples/index.html#using_credentials)

- [发布凭据](https://docs.gradle.org/current/samples/sample_publishing_credentials.html)：发布到受密码保护的存储库
- [向外部工具提供凭据](https://docs.gradle.org/current/samples/sample_credentials_for_external_tool_via_stdin.html)：使用 Gradle 属性通过标准输入将凭据传递给外部工具。

## [编写自定义任务](https://docs.gradle.org/current/samples/index.html#writing_custom_tasks)

- [使用命令行参数实现任务](https://docs.gradle.org/current/samples/sample_task_with_arguments.html)：将参数传递给自定义任务。